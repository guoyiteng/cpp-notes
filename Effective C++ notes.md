# Introduction to C++

## Item 1: VIew C++ as a federation of languages of C, Object-Oriented C++, Template C++, and the STL

## Item 2: Prefer `consts`, `enums`, and `inlines` to `#defines`

## Item 3: Keyword const

### const member function
- const object invokes const method
- methods can be overloaded by const keyword (with const and without const)
-  Non-const object can invoke const method by default while const object cannot invoke non-const object.
```c++
const char& TextBlock::operator[](std::size_t position) const {
    return this->text[position];
}
char& TextBlock::operator[](std::size_t position) {
    return this->text[position];
}
int main(int argc, char **argv) {
    TextBlock tb("abc");
    const TextBlock ctb("abc");
    std::cout << tb[0] << ctb[0] << std::endl;
}
```

### Keyword: mutable
- c++ compiler enforces const member method could not change any bit of its object.
- In order to implement logical constness rather than bit constness, mutable can be used on non-static member variables so that they can change in const method.
```c++
class CTextBlock {
public:
    std::size_t length() const;
private:
	char *pText;
	mutable std::size_t textLength;
	mutable bool lengthIsValid; 
};
// const method changes mutable member variables.
std::size_t CTextBlock::length() const {
	if (!lengthIsValid) {
		textLength = std::strlen(pText); lengthIsValid = true;
	}
 	return textLength; 
}
```

### Avoid Duplication in `const` and non-`const` methods
- `static_cast<const T&>()`: up-cast, type safe
- `const_cast<T&>()`: cast `const T&` to `T&`
```c++
char& operator[](std::size_t position)
{
    return const_cast<char&>( // remove const
    	// use static_cast here to avoid recursively call non-const method
    	static_cast<const TextBlock&>(*this)[position]
    );
}
```

## Item 4: Initialization of objects

### Uninitialized values or objects
- value: undefined behavior.
- object: invoked its default constructors.
- Therefore, we should always initialize every fields in the constructors.

### Prefer initialization list to pseudo-initilization via assignment 
- In general, it is faster to use initialization list. Sometimes, in order to reduce the duplication or initialize fields using files or database, it is fine to use assignment instead.

### Uncertain initialization order of non-local static objects
- Suppose you have two static objects in the non-local scope, and one of them uses the other one in its constructor. The compiler has no definite order to initialize these two objects so it is possible for an object to use an uninitialized object in its constructor. In order to solve this problem, we should use a singleton pattern where has a global function to return a local static object.
```c++
FileSystem& tfs()
{
    static FileSystem fs; // only initialized once at the first time when it gets called.
    return fs;
}
```
- Meanwhile, in order to avoid race condition in a multi-threaded program, it is a good practice to  call all these reference-returning functions during a single-threaded startup at the beginning of the program to make sure every static objects are initialized correctly.

# Constructors, Destructors, and Assignment Operators

## Item 5: Default constructor, destructor, copy constructor, and copy assignment operator

The default implementations are generated by the compiler only if they are used somewhere in the program.

### Constructor and Destructor
- The default behavior is to invoke the constructor and the destructor of the parent classes and non-static fields.
- There is no need to explicity destroy the parent class and fields in a destructor. It will destroy them by default after the destructor is invoked.
- Note that the default destructor is non-virtual unless the parent class itself declares a virtual destructor. If the class is intended to be inherited, it is safer to have an explicit virtual default destructor (See the following example). However, the code will be less redundant with a non-virtual destrutor for a class that is not intended to be inherited.
```c++
class B
{
public:
	// use virtual ~B() = default; if you want an empty virtual destructor.
    virtual ~B()
    {
        cout<<"B destructor"<<endl;
    }
};
class D : public B
{
public:
	// No need to explicity invoke ~B().
	// It will be automatically invoked after ~D().
    virtual ~D()
    {
        cout<<"D destructor"<<endl;
    }
};

// Output 'B destructor' and 'D destructor' if ~B() is virtual.
// Otherwise, only ~B() is called.
// Same thing happens with smart pointers.
B *pD = new D();
delete pD;
```

### Copy Constructor
- The default behavior is to invoke copy constructors of all members and its base class, and copy the bits for built-in type.
```c++
// Copy Constructor
A(const A& rhs) {...}
```

### Copy Assignment Constructor
- The compiler will try its best to provide a default implementation for Copy Assignment Constructor. It fails to do so if a reference member or a const member exists. A custom implementaion must be provided if it wants to be supported. You can also disable it by declaring `= delete`.
- Implicit Copy Assignment Constructor is rejected by the compiler if the base class declares its Copy Assignment Constructor as private. 
```c++
// Copy Constructor
A(const A& rhs) {...}
// Copy Assignment Constructor
A& operator=(const A& rhs) {...}
```

## Item 6: Explicitly disallow the use of compiler generated functions you do not want.

If you want to disable copy constructor and copy assignment operator, you can declare it as private or have it inherit from Noncopyable in boost. In modern c++, `= delete` can be used after function declaration to prevent that function from being used.

## Item 7: Declare destructors virtual in polymorphic base classes.

The general approach is to make the destructor virtual if and only if the class has at least one virtual function. It would save space (vptr space) if the destructor is non-virtual. However, it would cause partial destroyed object problem if we delete a pointer to the base class while it actually points to the subclass. In modern c++, you can use `class Point final` to make the class non-subclassable so that the use of non-virtual constructor is very safe.

## Item 8: Prevent exceptions from leaving destructors.

Always try and catch exceptions in destructors.

## Item 9: Never call virtual functions during construction or destruction.

In c++, when the base class constructor is invoked by the subclass, the runtime will consider `this` as type of the base class. Therefore, if we call a virtual function in the constructor, it will call the version of the base class instead of that of the subclass. Therefore, it is misleading to use virtual functions in constructors or destructors.

## Item 10: Have assignment operators return a reference to `*this`.

Assignment is right-associative and all built-in primitive assignments will return a reference to its left-hand argument. It is a convention we should follow in c++.
```c++
Widget& operator=(const Widget& rhs) { ...; return *this; }
Widget& operator+=(const Widget& rhs) { ...; return *this; }
Widget& operator=(int rhs) {...; return *this; }
```

## Item 11: Handle assignment to self in `operator=`.

Copy assignment operator can perform self assignment. It will generate some unsafe code if we use a nake pointer and forget to do the identity check.
```c++
Widget::operator=(const Widget& rhs)
{
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
}
```
Though this problem can be easily solved by adding an identity check `this == &rhs` at the beginning of this function, it did not rule out exception unsafeness. Instead, we could reorder statements to fix both at the same time.
```c++
Widget::operator=(const Widget& rhs)
{
    Bitmap *pOrig = pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this;
}
```
Another way to solve it is using the fact that passing something by value makes a copy of it. This version might be more efficient but it sacrifices calrity for efficiency.
```c++
// You can also call Widget(rhs) to get a copy if you prefer const Widget& rhs.
Widget::operator=(Widget rhs)
{	
    swap(rhs); // swap is a helper function to swap member variables between this and rhs.
    return *this;
}
```

## Item 12: Copy all parts of an object.

If you write your own version of copy constructor or copy assignment operator, the compiler will not do anything for you. You need to take care of any member variables and even those in the base class.
```c++
// class B: public A
B& B::operator=(const B& rhs)
{
    //...
    A::operator=(rhs);
    b = rhs.b
    return *this;
}
```

# Resource Management

## Item 13: Use objects to manage resources.

Never use a naked pointer. Use objects such as `auto_ptr`, `unqiue_ptr`, or `shared_ptr` to manage the memory allocation. Note that these smart pointers will only do `delete` instead of `delete []` so you should not manage a dynamically allocated arrays using them.

## Item 14: Think carefully about copying behavior in resource-managing classes.

- Prohibit copying: `= delete` for resources like Lock.
- Reference-count the underlying resource: Use `shared_ptr` to manage reference counts. You can provide a deleter function as the second argument to `shared_ptr`, which is invoked when the count is zero.
- Copy the underlying resource: Deep copy, such as `std::string`.
- Transfer ownership of the underlying resource: Nullify the previous object, such as `auto_ptr`.

## Item 15: Provide access to raw resources in resource-managing classes.

- Provide a `get()` method to expose the underlying resource or the bare pointer.
- Or we could implement an implicit conversion from resource managing class to its underlying resources. In general, this approach is error-prone and not recommended.
```c++
class Font {
public:
    operator FontHandle() const // implicit conversion to FontHandle
    { return f; }
}
```

## Item 16: Use the same form in corresponding uses of `new` and `delete`.

If you use `[]` in a `new` expression, you m ust use `[]` in the corresponding `delete` expression. Attention is needed when `typedef int lines[4]` is present. In this case, we do `int *p = new lines` and `delete [] p`.

## Item 17: Store newed objects in smart pointers in standalone statements.

```c++
// DO NOT DO THIS! The compiler might reorder the execution of the arguments.
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());
// DO THIS INSTEAD!
std::shared_ptr<Widget> pw(new Widget);
processWidget(pw, priority());
```

# Designs and Declarations

## Item 18: Make interfaces easy to use correctly and hard to use incorrectly.

C++ will implicitly use the constructor to do the type conversion if the constructor is not declared with `explicit`.

## Item 19: Treat class design as type design.

## Item 20: Item 20: Prefer pass-by-reference-to-const to pass-by- value.

### Slicing problem
it happens when a derived class object is padded by value as a base class object. Consider
```c++
class Window { 
public:
  ...
  std::string name() const; 
  virtual void display() const;
  // return name of window
  // draw window and contents
};
class WindowWithScrollBars: public Window { 
public:
  ...
  virtual void display() const; 
};

void printNameAndDisplay(Window w) {
  std::cout << w.name();
  w.display( ); 
}

// execute the following codes
WindowWithScrollBars wwsb;
printNameAndDisplay(wwsb);
```
If we pass by value here, `Window::display` will be always called instead of `WindowWithScrollBars::display`. Passing by reference-to-const can solve this problem.

## Item 21: Don’t try to return a reference when you must return an object.

Never return a pointer or reference to a local stack object, a reference to a heap-allocated object, or a pointer or reference to a local static object if there is a chance that more than one such object will be needed.

## Item 22: Declare data members private.

Implementing access to a data member through a member function provides a better encapsulation.

## Item 23: Prefer non-member non-friend functions to member functions.

Encapsulation implies flexibility. The level of encapsulation could be approximated by the number of functions which can access the private parts of the class. Therefore, non-member non-friend functions could reduce codes to access them and provide a better encapsulation. See the following example for reference. (Personally, I don't agree with this item) 
```c++
// Prefer to do
void clearBrowser(WebBrowser& wb)
{
	wb.clearCache( ); 
	wb.clearHistory( ); 
	wb.removeCookies( );
}
// rather than
class WebBrowser { 
public:
  ...
  void clearEverything();
  ... 
};
```

Organize classes and functions in the following way. For a client interested only in bookmark-related convenience functions, it does not have to include `webbrowsercookies.h`.

```c++
// header “webbrowser.h” — header for class WebBrowser itself
// as well as “core” WebBrowser-related 
namespace WebBrowserStuff {
	class WebBrowser { ... }; 
	...
  // “core” related functionality, 
  // e.g. non-member functions almost all clients need
}
 
// header “webbrowserbookmarks.h” 
namespace WebBrowserStuff {
	... 
  // bookmark-related convenience functions
}

// header “webbrowsercookies.h” 
namespace WebBrowserStuff {
  ...
  // cookie-related convenience functions
}
```

## Item 24: Declare non-member functions when type conversions should apply to all parameters.

### It is generally a bad idea to do so!

Overload a multiplication operator using non-member functions could solve problem like
```c++
Rational oneFourth(1, 4)
result = oneFourth * 2; // fine
result = 2 * oneFourth; // only works with a non-member function
```

## Item 25: Consider support for a non-throwing swap.

### Specialize a template function.

```c++
namespace std {
  template<>
  void swap<Widget>(Widget& a, Widget& b)
  {
    a.swap(b);
  }
}
```

This approach generally works for a regular class `Widget`. However, for a template class `Widget<T>`, c++ disallow us to specialize a template function with a template class. What we could do is to overload the swap function. In addition, by convention, it is not safe to add any function to namespace `std` (but a specialized template function is fine), so we add it to namespace `WidgetStuff`.

```c++
namespace WidgetStuff { 
  ...
  template<typename T> 
  class Widget { ... };
  ...
  
  // overload the swap in the namespace `WidgetStuff`.
  template<typename T> 
  void swap(Widget<T>& a, Widget<T>& b)
  {
  a.swap(b);
  }
}
```

From the client side, the correct way to call the swap function is

```c++
template<typename T>
void doSomething(T& obj1, T& obj2) {
  using std::swap; // make std::swap available in this function.
  ...
  swap(obj1, obj2); // let compiler decide which one is the best one to use.
  ...
}
```

c++ name lookup rules could find the desired `swap` in the example above. It will prefer `swap` in the namespace where its argument is located (`WidgetStuff`) to namespace `std`. However, if we invoke it by `std::swap(obj1, obj2)`, it forces our compiler to use the `std` version of swap, which is not the desired result.

# Implementations

## Item 26: Postpone variable definitions as long as possible.

Call constructor of a variable as late as possible. In the scenario of loop, prefer to call constructor inside loop rather than do the assignment unless assignment is much cheaper than constructor and destructor pair. (This convention does not contaminate variable names in a larger scope.) 

## Item 27: Minimize casting.

### Old Style Casts (c style)

`(T) expression` or `T(expression)`: Call the constructor of `T` when possible.

### New Style Casts (c++ style)

-`const_cast<T>(expression)`: Cast away the constness of objects. It is the only c++ cast that can do this.
-`dynamic_cast<T>(expression)`: Safe downcasting. Have a significant runtime cost. Return a null pointer if it cannot be done for pointer type (For reference type, an exception will be thrown). With this feature, we can do 

```c++
if (SW *sw = dynamic_cast<SW*>(w)) {
	...
}
```
-`reinterpret_cast<T>(expression)`: Intended for low-level casts. It may yield some unportabnle results (cast a pointer to int). It should be rarely used.
-`static_cast<T>(expression)`: Force implicit converseions (non-const to const). Also can perform the reverse of such conversions (void\* to typed pointer). 

A signle object in c++ might have more than one address due to multiple inheritance or single inheritance sometimes. We should generally avoid making assumptions about object layout in c++. 

In a derived class, when we want to invoke a member function in the base class, `static_cast` is not the correct way to do.
```c++
class Window { 
public:
  virtual void onResize() { ... }
  ... 
};

// WRONG WAY!
class SpecialWindow: public Window { 
public:
  virtual void onResize() { 
    static_cast<Window>(*this).onResize( );
    // It in fact creates a copy of this object
    // and perform onResize on that copy.
  }
};

// CORRECT WAY
class SpecialWindow: public Window { 
public:
  virtual void onResize() { 
    Window::onResize();
  }
};
```

## Item 28: Avoid returning "handles" to object internals.

It tends to break the encapsulation and possibly leads to dangling handles.

## Item 29: Strive for exception-safe code.

- Basic Guarantee: If an exception is thrown, everything in the program remains in a vlid state.
- Strong Guarantee: If an exception is thrown, the state of the program is unchanged.
- Nothrow Guarantee: Never throw exceptions.

## Item 30: Understand the ins and outs of inlining.

`inline` is a request to compilers, not a command. The compiler could refuse to do so (will give warnings if it happens). The general strategy for inlining is to limit inlining to those functions that must be inline or truly trivial.

## Item 31: Minimize compilation dependencies between files.

### Forward Declaration
Use forward declaration instead of `#include` to replace dependencies on *definitions* with dependencies on *declarations*.
```c++
class Date;

Date today();
void clearAppointments(Date d);
```
We call it incomplete type. It is possible to use incomplete type to declare functions parameter/return type. Its pointer/reference type can be used anywhere since we don't need the incomplete type's information to acquire the size of a pointer. However, it is impossible to use it as a class member, in a function definition, or as a template parameter. Refer to [`item31.cpp`](./item31.cpp) for more details and examples. Forward headers such as `<iosfwd>` utilize this feature and should be preferred if exist.

###  Handle Classes

Employ the pimpl idiom and only expose a pointer in the header file. With the help of forward declaration, we can get rid of the dependencies on definitions.

### Interface Classes

Expose an interface class with no data members, no constructors, a virtual destructor, and a set of pure virtual functions. Then, the concrete class can inherit this interface to provide the implementation and hide its definition from clients. The trick here is to have a static factory method in the interface class such as
```c++
std::tr1::shared_ptr<Person> Person::create(const std::string& name, const Date& birthday, const Address& addr)
{
	return std::tr1::shared_ptr<Person>(new RealPerson( name, birthday, addr));
}
```

Note that this function's declaration does not depend on `RealPerson` so it decouples interfaces from implementations.

# Inheritance and Object-Oriented Design

##  Item 32: Make sure public inheritance models "is-a".

## Item 33: Avoid hiding inherited names.

```c++
class Base {
public:
  virtual void mf1() = 0;
  virtual void mf1(int);
};
class Derived: public Base {
public:
  void mf1();
};

Derived d;
d.mf1(); // fine, calls Derived::mf1
d.mf1(42); // compiler error! Derived::mf1 hides Base::mf1
```

When we declare a method with name `mf1`, it hides everything named `mf1` from the `Base` class by c++ scoping rules (search first in current class then in base class). Scoping rules only care about name but not signature. To resolve this problem and expose both versions of `mf1`, we should do the following:

```c++
class Base {
public:
  virtual void mf1() = 0;
  virtual void mf1(int);
};
class Derived: public Base {
public:
  using Base::mf1;
  void mf1();
};

Derived d;
d.mf1(); // fine, calls Derived::mf1
d.mf1(42); // fine, calls Base::mf1(int)
```

## Item 34: Differentiate between inheritance of interface and inheritance of implementation.

