# Introduction to C++

## Item 1: VIew C++ as a federation of languages of C, Object-Oriented C++, Template C++, and the STL

## Item 2: Prefer `consts`, `enums`, and `inlines` to `#defines`

## Item 3: Keyword const

### const member function
- const object invokes const method
- methods can be overloaded by const keyword (with const and without const)
-  Non-const object can invoke const method by default while const object cannot invoke non-const object.
```c++
const char& TextBlock::operator[](std::size_t position) const {
    return this->text[position];
}
char& TextBlock::operator[](std::size_t position) {
    return this->text[position];
}
int main(int argc, char **argv) {
    TextBlock tb("abc");
    const TextBlock ctb("abc");
    std::cout << tb[0] << ctb[0] << std::endl;
}
```

### Keyword: mutable
- c++ compiler enforces const member method could not change any bit of its object.
- In order to implement logical constness rather than bit constness, mutable can be used on non-static member variables so that they can change in const method.
```c++
class CTextBlock {
public:
    std::size_t length() const;
private:
	char *pText;
	mutable std::size_t textLength;
	mutable bool lengthIsValid; 
};
// const method changes mutable member variables.
std::size_t CTextBlock::length() const {
	if (!lengthIsValid) {
		textLength = std::strlen(pText); lengthIsValid = true;
	}
 	return textLength; 
}
```

### Avoid Duplication in `const` and non-`const` methods
- `static_cast<const T&>()`: up-cast, type safe
- `const_cast<T&>()`: cast `const T&` to `T&`
```c++
char& operator[](std::size_t position)
{
    return const_cast<char&>( // remove const
    	// use static_cast here to avoid recursively call non-const method
    	static_cast<const TextBlock&>(*this)[position]
    );
}
```

## Item 4: Initialization of objects

### Uninitialized values or objects
- value: undefined behavior.
- object: invoked its default constructors.
- Therefore, we should always initialize every fields in the constructors.

### Prefer initialization list to pseudo-initilization via assignment 
- In general, it is faster to use initialization list. Sometimes, in order to reduce the duplication or initialize fields using files or database, it is fine to use assignment instead.

### Uncertain initialization order of non-local static objects
- Suppose you have two static objects in the non-local scope, and one of them uses the other one in its constructor. The compiler has no definite order to initialize these two objects so it is possible for an object to use an uninitialized object in its constructor. In order to solve this problem, we should use a singleton pattern where has a global function to return a local static object.
```c++
FileSystem& tfs()
{
    static FileSystem fs; // only initialized once at the first time when it gets called.
    return fs;
}
```
- Meanwhile, in order to avoid race condition in a multi-threaded program, it is a good practice to  call all these reference-returning functions during a single-threaded startup at the beginning of the program to make sure every static objects are initialized correctly.

# Constructors, Destructors, and Assignment Operators

## Item 5: Default constructor, destructor, copy constructor, and copy assignment operator

The default implementations are generated by the compiler only if they are used somewhere in the program.

### Constructor and Destructor
- The default behavior is to invoke the constructor and the destructor of the parent classes and non-static fields.
- There is no need to explicity destroy the parent class and fields in a destructor. It will destroy them by default after the destructor is invoked.
- Note that the default destructor is non-virtual unless the parent class itself declares a virtual destructor. If the class is intended to be inherited, it is safer to have an explicit virtual default destructor (See the following example). However, the code will be less redundant with a non-virtual destrutor for a class that is not intended to be inherited.
```c++
class B
{
public:
	// use virtual ~B() = default; if you want an empty virtual destructor.
    virtual ~B()
    {
        cout<<"B destructor"<<endl;
    }
};
class D : public B
{
public:
	// No need to explicity invoke ~B().
	// It will be automatically invoked after ~D().
    virtual ~D()
    {
        cout<<"D destructor"<<endl;
    }
};

// Output 'B destructor' and 'D destructor' if ~B() is virtual.
// Otherwise, only ~B() is called.
// Same thing happens with smart pointers.
B *pD = new D();
delete pD;
```

### Copy Constructor
- The default behavior is to invoke copy constructors of all members and its base class, and copy the bits for built-in type.
```c++
// Copy Constructor
A(const A& rhs) {...}
```

### Copy Assignment Constructor
- The compiler will try its best to provide a default implementation for Copy Assignment Constructor. It fails to do so if a reference member or a const member exists. A custom implementaion must be provided if it wants to be supported. You can also disable it by declaring `= delete`.
- Implicit Copy Assignment Constructor is rejected by the compiler if the base class declares its Copy Assignment Constructor as private. 
```c++
// Copy Constructor
A(const A& rhs) {...}
// Copy Assignment Constructor
A& operator=(const A& rhs) {...}
```

## Item 6: Explicitly disallow the use of compiler generated functions you do not want.

If you want to disable copy constructor and copy assignment operator, you can declare it as private or have it inherit from Noncopyable in boost. In modern c++, `= delete` can be used after function declaration to prevent that function from being used.

## Item 7: Declare destructors virtual in polymorphic base classes.

The general approach is to make the destructor virtual if and only if the class has at least one virtual function. It would save space (vptr space) if the destructor is non-virtual. However, it would cause partial destroyed object problem if we delete a pointer to the base class while it actually points to the subclass. In modern c++, you can use `class Point final` to make the class non-subclassable so that the use of non-virtual constructor is very safe.

## Item 8: Prevent exceptions from leaving destructors.

Always try and catch exceptions in destructors.

## Item 9: Never call virtual functions during construction or destruction.

In c++, when the base class constructor is invoked by the subclass, the runtime will consider `this` as type of the base class. Therefore, if we call a virtual function in the constructor, it will call the version of the base class instead of that of the subclass. Therefore, it is misleading to use virtual functions in constructors or destructors.

## Item 10: Have assignment operators return a reference to `*this`.

Assignment is right-associative and all built-in primitive assignments will return a reference to its left-hand argument. It is a convention we should follow in c++.
```c++
Widget& operator=(const Widget& rhs) { ...; return *this; }
Widget& operator+=(const Widget& rhs) { ...; return *this; }
Widget& operator=(int rhs) {...; return *this; }
```

## Item 11: Handle assignment to self in `operator=`.

Copy assignment operator can perform self assignment. It will generate some unsafe code if we use a naked pointer and forget to do the identity check.
```c++
Widget::operator=(const Widget& rhs)
{
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
}
```
Though this problem can be easily solved by adding an identity check `this == &rhs` at the beginning of this function, it did not rule out exception unsafeness. Instead, we could reorder statements to fix both at the same time.
```c++
Widget::operator=(const Widget& rhs)
{
    Bitmap *pOrig = pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this;
}
```
Another way to solve it is using the fact that passing something by value makes a copy of it. This version might be more efficient but it sacrifices calrity for efficiency.
```c++
// You can also call Widget(rhs) to get a copy if you prefer const Widget& rhs.
Widget::operator=(Widget rhs)
{	
    swap(rhs); // swap is a helper function to swap member variables between this and rhs.
    return *this;
}
```

## Item 12: Copy all parts of an object.

If you write your own version of copy constructor or copy assignment operator, the compiler will not do anything for you. You need to take care of any member variables and even those in the base class.
```c++
// class B: public A
B& B::operator=(const B& rhs)
{
    //...
    A::operator=(rhs);
    b = rhs.b
    return *this;
}
```

# Resource Management

## Item 13: Use objects to manage resources.

Never use a naked pointer. Use objects such as `auto_ptr`, `unqiue_ptr`, or `shared_ptr` to manage the memory allocation. Note that these smart pointers will only do `delete` instead of `delete []` so you should not manage a dynamically allocated arrays using them.

## Item 14: Think carefully about copying behavior in resource-managing classes.

- Prohibit copying: `= delete` for resources like Lock.
- Reference-count the underlying resource: Use `shared_ptr` to manage reference counts. You can provide a deleter function as the second argument to `shared_ptr`, which is invoked when the count is zero.
- Copy the underlying resource: Deep copy, such as `std::string`.
- Transfer ownership of the underlying resource: Nullify the previous object, such as `auto_ptr`.

## Item 15: Provide access to raw resources in resource-managing classes.

- Provide a `get()` method to expose the underlying resource or the bare pointer.
- Or we could implement an implicit conversion from resource managing class to its underlying resources. In general, this approach is error-prone and not recommended.
```c++
class Font {
public:
    operator FontHandle() const // implicit conversion to FontHandle
    { return f; }
}
```

## Item 16: Use the same form in corresponding uses of `new` and `delete`.

If you use `[]` in a `new` expression, you must use `[]` in the corresponding `delete` expression. Attention is needed when `typedef int lines[4]` is present. In this case, we do `int *p = new lines` and `delete [] p`.

## Item 17: Store newed objects in smart pointers in standalone statements.

```c++
// DO NOT DO THIS! The compiler might reorder the execution of the arguments.
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());
// DO THIS INSTEAD!
std::shared_ptr<Widget> pw(new Widget);
processWidget(pw, priority());
```

# Designs and Declarations

## Item 18: Make interfaces easy to use correctly and hard to use incorrectly.

C++ will implicitly use the constructor to do the type conversion if the constructor is not declared with `explicit`.

## Item 19: Treat class design as type design.

## Item 20: Item 20: Prefer pass-by-reference-to-const to pass-by- value.

### Slicing problem
it happens when a derived class object is padded by value as a base class object. Consider
```c++
class Window { 
public:
  ...
  std::string name() const; 
  virtual void display() const;
  // return name of window
  // draw window and contents
};
class WindowWithScrollBars: public Window { 
public:
  ...
  virtual void display() const; 
};

void printNameAndDisplay(Window w) {
  std::cout << w.name();
  w.display( ); 
}

// execute the following codes
WindowWithScrollBars wwsb;
printNameAndDisplay(wwsb);
```
If we pass by value here, `Window::display` will be always called instead of `WindowWithScrollBars::display`. Passing by reference-to-const can solve this problem.

## Item 21: Don’t try to return a reference when you must return an object.

Never return a pointer or reference to a local stack object, a reference to a heap-allocated object, or a pointer or reference to a local static object if there is a chance that more than one such object will be needed.

## Item 22: Declare data members private.

Implementing access to a data member through a member function provides a better encapsulation.

## Item 23: Prefer non-member non-friend functions to member functions.

Encapsulation implies flexibility. The level of encapsulation could be approximated by the number of functions which can access the private parts of the class. Therefore, non-member non-friend functions could reduce codes to access them and provide a better encapsulation. See the following example for reference. (Personally, I don't agree with this item) 
```c++
// Prefer to do
void clearBrowser(WebBrowser& wb)
{
	wb.clearCache( ); 
	wb.clearHistory( ); 
	wb.removeCookies( );
}
// rather than
class WebBrowser { 
public:
  ...
  void clearEverything();
  ... 
};
```

Organize classes and functions in the following way. For a client interested only in bookmark-related convenience functions, it does not have to include `webbrowsercookies.h`.

```c++
// header “webbrowser.h” — header for class WebBrowser itself
// as well as “core” WebBrowser-related 
namespace WebBrowserStuff {
	class WebBrowser { ... }; 
	...
  // “core” related functionality, 
  // e.g. non-member functions almost all clients need
}
 
// header “webbrowserbookmarks.h” 
namespace WebBrowserStuff {
	... 
  // bookmark-related convenience functions
}

// header “webbrowsercookies.h” 
namespace WebBrowserStuff {
  ...
  // cookie-related convenience functions
}
```

## Item 24: Declare non-member functions when type conversions should apply to all parameters.

### It is generally a bad idea to do so!

Overload a multiplication operator using non-member functions could solve problem like
```c++
Rational oneFourth(1, 4)
result = oneFourth * 2; // fine
result = 2 * oneFourth; // only works with a non-member function
```

## Item 25: Consider support for a non-throwing swap.

### Specialize a template function.

```c++
namespace std {
  template<>
  void swap<Widget>(Widget& a, Widget& b)
  {
    a.swap(b);
  }
}
```

This approach generally works for a regular class `Widget`. However, for a template class `Widget<T>`, c++ disallow us to specialize a template function with a template class. What we could do is to overload the swap function. In addition, by convention, it is not safe to add any function to namespace `std` (but a specialized template function is fine), so we add it to namespace `WidgetStuff`.

```c++
namespace WidgetStuff { 
  ...
  template<typename T> 
  class Widget { ... };
  ...
  
  // overload the swap in the namespace `WidgetStuff`.
  template<typename T> 
  void swap(Widget<T>& a, Widget<T>& b)
  {
  a.swap(b);
  }
}
```

From the client side, the correct way to call the swap function is

```c++
template<typename T>
void doSomething(T& obj1, T& obj2) {
  using std::swap; // make std::swap available in this function.
  ...
  swap(obj1, obj2); // let compiler decide which one is the best one to use.
  ...
}
```

c++ name lookup rules could find the desired `swap` in the example above. It will prefer `swap` in the namespace where its argument is located (`WidgetStuff`) to namespace `std`. However, if we invoke it by `std::swap(obj1, obj2)`, it forces our compiler to use the `std` version of swap, which is not the desired result.

# Implementations

## Item 26: Postpone variable definitions as long as possible.

Call constructor of a variable as late as possible. In the scenario of loop, prefer to call constructor inside loop rather than do the assignment unless assignment is much cheaper than constructor and destructor pair. (This convention does not contaminate variable names in a larger scope.) 

## Item 27: Minimize casting.

### Old Style Casts (c style)

`(T) expression` or `T(expression)`: Call the constructor of `T` when possible.

### New Style Casts (c++ style)

-`const_cast<T>(expression)`: Cast away the constness of objects. It is the only c++ cast that can do this.
-`dynamic_cast<T>(expression)`: Safe downcasting. Have a significant runtime cost. Return a null pointer if it cannot be done for pointer type (For reference type, an exception will be thrown). With this feature, we can do 

```c++
if (SW *sw = dynamic_cast<SW*>(w)) {
	...
}
```
-`reinterpret_cast<T>(expression)`: Intended for low-level casts. It may yield some unportabnle results (cast a pointer to int). It should be rarely used.
-`static_cast<T>(expression)`: Force implicit converseions (non-const to const). Also can perform the reverse of such conversions (void\* to typed pointer). 

A signle object in c++ might have more than one address due to multiple inheritance or single inheritance sometimes. We should generally avoid making assumptions about object layout in c++. 

In a derived class, when we want to invoke a member function in the base class, `static_cast` is not the correct way to do.
```c++
class Window { 
public:
  virtual void onResize() { ... }
  ... 
};

// WRONG WAY!
class SpecialWindow: public Window { 
public:
  virtual void onResize() { 
    static_cast<Window>(*this).onResize( );
    // It in fact creates a copy of this object
    // and perform onResize on that copy.
  }
};

// CORRECT WAY
class SpecialWindow: public Window { 
public:
  virtual void onResize() { 
    Window::onResize();
  }
};
```

## Item 28: Avoid returning "handles" to object internals.

It tends to break the encapsulation and possibly leads to dangling handles.

## Item 29: Strive for exception-safe code.

- Basic Guarantee: If an exception is thrown, everything in the program remains in a vlid state.
- Strong Guarantee: If an exception is thrown, the state of the program is unchanged.
- Nothrow Guarantee: Never throw exceptions.

## Item 30: Understand the ins and outs of inlining.

`inline` is a request to compilers, not a command. The compiler could refuse to do so (will give warnings if it happens). The general strategy for inlining is to limit inlining to those functions that must be inline or truly trivial.

## Item 31: Minimize compilation dependencies between files.

### Forward Declaration
Use forward declaration instead of `#include` to replace dependencies on *definitions* with dependencies on *declarations*.
```c++
class Date;

Date today();
void clearAppointments(Date d);
```
We call it incomplete type. It is possible to use incomplete type to declare functions parameter/return type. Its pointer/reference type can be used anywhere since we don't need the incomplete type's information to acquire the size of a pointer. However, it is impossible to use it as a class member, in a function definition, or as a template parameter. Refer to [`item31.cpp`](./item31.cpp) for more details and examples. Forward headers such as `<iosfwd>` utilize this feature and should be preferred if exist.

###  Handle Classes

Employ the pimpl idiom and only expose a pointer in the header file. With the help of forward declaration, we can get rid of the dependencies on definitions.

### Interface Classes

Expose an interface class with no data members, no constructors, a virtual destructor, and a set of pure virtual functions. Then, the concrete class can inherit this interface to provide the implementation and hide its definition from clients. The trick here is to have a static factory method in the interface class such as
```c++
std::tr1::shared_ptr<Person> Person::create(const std::string& name, const Date& birthday, const Address& addr)
{
	return std::tr1::shared_ptr<Person>(new RealPerson( name, birthday, addr));
}
```

Note that this function's declaration does not depend on `RealPerson` so it decouples interfaces from implementations.

# Inheritance and Object-Oriented Design

##  Item 32: Make sure public inheritance models "is-a".

## Item 33: Avoid hiding inherited names.

```c++
class Base {
public:
  virtual void mf1() = 0;
  virtual void mf1(int);
};
class Derived: public Base {
public:
  void mf1();
};

Derived d;
d.mf1(); // fine, calls Derived::mf1
d.mf1(42); // compiler error! Derived::mf1 hides Base::mf1
```

When we declare a method with name `mf1`, it hides everything named `mf1` from the `Base` class by c++ scoping rules (search first in current class then in base class). Scoping rules only care about name but not signature. To resolve this problem and expose both versions of `mf1`, we should do the following:

```c++
class Base {
public:
  virtual void mf1() = 0;
  virtual void mf1(int);
};
class Derived: public Base {
public:
  using Base::mf1;
  virtual void mf1();
};

Derived d;
d.mf1(); // fine, calls Derived::mf1
d.mf1(42); // fine, calls Base::mf1(int)
```

## Item 34: Differentiate between inheritance of interface and inheritance of implementation.

- **Pure virtual function**: inherit a function interface only.
It is possible to provide an implementation for a pure virtual function. It is useful when one wants to forbid implicit inheritance of the default implementation. It forces programmers to provide an implementation for the virtual function explicitly and retains the convenience of the default implementation.
```c++
class Airplane {
public:
	virtual void fly(const Airport& destination) = 0; 
};

void Airplane::fly(const Airport& destination) { /* default implementation */}

class ModelA: public Airplane {
public:
  virtual void fly(const Airport& destination) {
    Airplane::fly(destination); // explicitly use the default implementation
  }
};
```

- **Simple virtual function**: inherit a function interface as well as a default implementation.
- **Non-virtual function**: inherit a function interface as well as a mandatory implementation. It specifies an *invariant over specialization*.

## Item 35: Consider alternatives to virtual functions.

### Template Method Pattern via the Non-Virtual Interface Idion

An alternative to public virtual functions. Declare a public non-virtual (interface) function and a private virtual function. Invoke the private virtual function inside the public non-virtual function. Notice that c++ allows overriding a private function.

### Strategy Pattern via Function Pointers

Take a function pointer in the constructor. Use `typedef` or `std::function<>` to represent the type of the function pointer. The latter one is much more powerful because it allows any callable object in that form.
```c++
typedef int (*HealthCalcFunc)(const GameCharacter&);
// or in modern c++
using HealthCalcFunc = std::function<int (const GameCharacter&)>
```

## Item 36: Never redefine an inherited non-virtual function.

## Item 37: Never redefine a function's inherited default parameter value.

Default parameter values are statically bound, while virtual functions are dynamically bound. It will be confusing if we redefine a function's inherited default parameter value.

## Item 38: Model "has-a" or "is-implemented-in-terms-of" through composition.

For example, if we want to implement `set` using `list`. Instead of having `set` inherit from `list`, we should put `list` inside `set` as a private member.

## Item 39: Use private inheritance judiciously.

Private inheritance does not model "is-a" (subtyping) relationship. It models "has-a" relationship instead. With private inheritance, a class only inherits implementation but not interface. Consider two classes A and B where A has a B. The capability that private inheritance provides is to access protected members or redefine virtual function of B. However, it is also viable to have a private class inside A with public inheritance from B and then use composition. The advantage of composition over private inheritance is to prevent derived classes of A redefining virtual functions and minimize the compilation dependencies. The disadvantage fo composition is the problem of freestanding objects.
```c++
class Empty {}; // use no memory

class A {
private:
	int x;
	Empty e; // freestadning object
	// Compiler uses 1 empty byte to represent this empty object. 
	// Occupy more space due to alignment.
}

class A: private Empty {
private:
	int x;
	// sizeof(A) == sizeof(int)
	// Compiler will optimze empty base class under single inheritance
  // Empty Base Optimization.
};
```

## Item 40: Use multiple inheritance judiciously.

### Ambiguity when inherit the same name
```c++
class BorrowableItem {
public:
	void checkOut();
};

class ElectronicGadget {
private:
	bool checkOut() const;
};

class MP3Player: public BorrowableItem, public ElectronicGadget {
};

MP3Player mp;
mp.checkOut(); // Compiler Error!
```
Even though `checkOut()` in `ElectronicGadget` only has private accessiblity, the compiler still complains because name lookup happens before finding the best-match function. It is a conservative strategy for the compiler. We can use `mp.BorrowableItem::checkOut()` to get around this limitation.

### Deadly Multiple Inheritance Diamond
```c++
class File { ... };
class InputFile: public File { ... }; 
class OutputFile: public File { ... }; 
class IOFile: public InputFile, public OutputFile {...};
// or virtual inheritance
class InputFile: virtual public File { ... }; 
class OutputFile: virtual public File { ... }; 
class IOFile: public InputFile, public OutputFile {...};
```
Problem here is how many copies of fields in `File` `IOFile` should have. In c++, the default inheritance performs replication over all member fields and functions. It is possible to keep one copy by using *virtual inheritance* technique. Even though in most cases, *virtual inheritance* seems to be the correct way to go, it also incurs some performance costs and compilation complexities to access virtual base class's fields (In compiler, the most derived class is responsible for the initialization of the virtual base class now). The best practice here is to avoid putting data in virtual base classes, which leads to the c++ counterpart of Java interface.
```c++
class IPerson { // Interface, only declares functions to be implemented
public:
  virtual ~IPerson();
  virtual std::string name() const = 0;
  virtual std::string birthDate() const = 0; 
};

class PersonInfo { // Class, provides implementations to be inherited.
public:
	const char* theName() const;
}

class CPerson: public IPerson, private PersonInfo {
public:
	virtual std::string name() {
		return PersonInfo::theName();
	}
}
```
Multiple inheritance design is very useful here. Public inheritance is used to inherit interface while private inheritance is used to inherit implementation.

# Templates and Generic Programming

## Item 41: Understand implicit interfaces and compile-time polymorphism.

- Both classes and templates support interfaces and polymorphism.
- For classes, interfaces are explicit and centered on function signatures. Polymorphism occurs at runtime through virtual functions.
- For template parameters, interfaces are implicit and based on valid expressions. Polymorphism occurs during compilation through template instantiation and function overloading resolution.

## Item 42: Understand the two meanings of *typename*.

- When declaring template parameters, class and typename are interchangeable.
- Use *typename* to identify nested dependent type names, except in base class lists or as a base class identifier in a member initialization list.
```c++
template<typename C>
void print2nd(const C& container) {
	C::const_iterator * x; // C::const_iterator is a nested dependent name.
	// Ambiguous here! Declare a variable x with type C::const_iterator
	// or Multiply a static data member C::const_iterator with x
}
// c++ resolves this ambiguity by considering any nested dependent name is not type.
template<typename C>
void print2nd(const C& container) {
	// Need to put `typename` before the nested dependent name to tell c++ it is a type.
	typename C::const_iterator * x;
}
// Exception: `typename` must not appear in base class clists 
//            or as a base class identifier in a member initialization list
template<typename T> 
class Derived: public Base<T>::Nested { // disallowed.
public:
	explicit Derived(int x) : Base<T>::Nested(x) { // disallowed.
		typename Base<T>::Nested temp; // required.
	}
};
```

## Item 43: Know how to access names in templatized base classes.

When a class inherits from a templatized base class, we do not know if a function exists in the base class due to the possibility of total template specilization. Compiler will be conservative about this and disallow use of member functions/fields from the templatized base class. However, we can still access them if we explicitly specify it by `this->func()` or `using` syntax. Examples are shown below. 

```c++
template<typename Company>
class LoggingMsgSender: public MsgSender<Company> { 
public:
	void sendClearMsg(const MsgInfo& info) {
		sendClear(info); // sendClear is a member function in MsgSender
		// Complier Error here! Compiler does not know if MsgSender<Company>
		// implements sendClear()
	}
};

// It is possible that MsgSender<Company> does not implement sendClear with Total Template Specilization. 
// Compiler will use this implementation if the template argument is CompanyZ.
template<>
class MsgSender<CompanyZ> {
// does not include sendClear()
}

// Solution (within sendClearMsg):
this->sendClear(info);
// or
using MsgSender<Company>::sendClear;
sendClear(info);
```

## Item 44: Factor parameter-independent code out of templates.

Any template code not dependent on a template parameter causes bloat. It can be avoided by replacing template parameters with function parameters or class data members.

## Item 45: Use member function templates to accept "all compatible types."

In the following example, we allow implicit cast from `SmartPtr<U>` to `SmartPtr<T>` by implementing a generalized copy constructor. We use `ptr(other.get())` to make sure this implicit conversion is sensible because the compiler allows conversion from `U*` to `T*`. We can use the same technique on copy assignment operator. Note that generalized copy constructors are not copy constructor so the compiler will still generate a default copy constructor. We can override the default one by declaring a copy constructor for `SmartPtr`.
```c++
template<typename T>
class SmartPtr{
public:
  template<typename U>
  SmartPtr(const SmartPtr<U>& other) // template copy constructor to accept all SmartPtr.
  : ptr(other.get()) // implicitly convert from U* to T*.
  {}
  
  // We should use SmartPtr instead SmartPtr<T> to reference itself inside SmartPtr class.
  SmartPtr(const SmartPtr& other)
  : ptr(other.get())
  {}
  
private:
	T *ptr;
}
```

## Item 46: Define non-member functions inside templates when type conversions are desired.

Say we want to overload `operator*` for a class `Rational<T>`. Here are several ways to accomplish it.
```c++
template<typename T>
class Rational
{
public:
    Rational(T _n, T _d): n(_n), d(_d) {}
    Rational(T _n): n(_n), d(1) {}
    // option 1:
    // only work for R * 2 but not 2 * R
    const Rational operator*(const Rational& r) {
        return Rational(r.n * n, r.d * d);
    }
    
    // option 3:
    friend const Rational operator*(const Rational& l, const Rational& r);
    // define it outside this class.
    // Link Error! The compiler will not instantiate this friend function if it is defined outside this class.

    // option 4:
    // Work for every case including 2 * R and R * 2.
    friend const Rational operator*(const Rational& l, const Rational& r) {
        return Rational(r.n * l.n, r.d * l.d);
    }
private:
    T n, d;
};

// option 2:
template<typename T>
const Rational<T> operator*(const Rational<T>& l, const Rational<T>& r) {}
// It does not work for both 2 * R and R * 2 because compiler deduce
// the template function on parameter separately. It cannot deduce the
// implicit type conversion from 2 to Rational<int>;

```
Option 4 is the correct way to go. We use several techniques here. We can provide a definition for a friend function inside the class. Note that the friend function is still a non-member function even though it is defined inside the class. Within a template class, `Rational` is a shorthand for `Rational<T>` where `T` is the type parameter of this template class. The underlying reason that option 4 works but option 2 does not is that option 2 is a templatized function while option 4 is a function inside a templatized class. When deducing a function inside a templatized class, the c++ compiler will be smart and consider both parameters at the same time.

## Item 47: Use traits classes for information about types.

Trait is a technique we can use to distinguish the type parameter of a template class. See [`item47.cpp`](./item47.cpp) for an example. In realtiy, we can use `char_traits` to hold information about character types, `numeric_limits` to store the minimum and maximum of number types, and etc.

## Item 48: Be aware of template metaprogramming.

Template metaprogramming can shift work from runtime to compile-time, thus enabling earlier error detection and higher runtime performance. In modern c++, it can be achieved by `constexpr` instead of template.

# Customizing *new* and *delete*

## Item 49: Understand the behavior of the new-handler.

`set_new_handler` allows you to specify a function to be called when memory allocation requests cannot be satisfied. One can override a member function `static void* operator new(std::size_t size) throw(std::bad_alloc)` to customize the behavior of allocating memory for the specific class. Note that it only overrides the allocator (allocating the memory) but not the constructor (initializing the object) here.

## Item 50: Understand when it makes sense to replace *new* and *delete*.

 There are some valid reasons to customize `new` and `delete`, including improving performance, debugging heap usage errors, and collecting heap usage information. It is sometimes possible to use third-party implementation (Pool from Boost) to accomplish these goals. When customizing `new`, we should pay attention to the address alignment problem. c++ `new` and `malloc` return an address that aligns for any data type, and our implementation should also obey the alignment rule (could only align for a specific type if we know the data type we would `new`).

```c++
// customizing global new operator.
void* operator new(size_t size);

class A {
public:
  // customizing object new operator;
	static void* operator new(size_t size);  
}

// customizing global new array operator.
void* operator new[](size_t size) {
	// default implementation in clang.
  return ::operator new(size);
}
```

## Item 51: Adhere to convention when writing new and delete.

- Operator `new` should contain an infinite loop trying to allocate memory, should call the new-handler if it can't satisfy a memory request, and should handle requests for zero bytes. Class-specific versions should handle requests for larger blocks than expected because `new` is also inherited by the derived class.
- Operator `delete` should do nothing if passed a pointer that is null. Class-specific versions should handle blocks that are larger than expected.

## Item 52: Write placement delete if you write placement new.

- When you write a placement version of operator `new`, be sure to write the corresponding placement version of operator `delete`. The compiler runtime will invoke its corresponding placement version of `delete` when there is an exception in the constructor.

- When you declare placement versions of new and delete, be sure not to unintentionally hide the normal versions of those functions.

```c++
class StandardNewDeleteForm {
public:
	static void* operator new(std::size_t size) 
	{return ::operator new(size)}
	// omit other new and delete operators.
}

class Widget: public StandardNewDeleteForm {
public:
	using StandardNewDeleteForm::operator new;
	using StandardNewDeleteForm::operator delete;
	// using ::operator new; is wrong
	// because using declaration inside a class definition can only use its  base class.
}
```

# Miscellany

## Item 53: Pay attention to compiler warnings.

## Item 54: Familiarize yourself with the standard library, including TR1.

## Item 55: Familiarize yourself with Boost.